% Generated by roxygen2 (4.0.1.99): do not edit by hand
\name{x_}
\alias{x_}
\alias{x__}
\title{x_}
\usage{
x_(val)

x__(...)
}
\arguments{
\item{val}{an arbitrary value. The value to wrap in a kea object.}

\item{...}{see above.}
}
\value{
An object of class 'kea' which wraps the value supplied to x_. Internally, a 'kea' object is represented
    as a list with a single field - \bold{x} - but this field should never be accessed directly.
}
\description{
Make methods available to a value.
}
\details{
Kea allows functions to be used in both nested form - \bold{xLenOf(xRepeat(3, 'a'))} - and using method-chaining
    \bold{x_('a') $ xRepeat(3) $ x_LenOf()}. These two syntaxes are equivalent, but method-chaining syntax is better when
    you need to apply many function to an initial value: balancing parentheses is easier and you read the function calls from
    left to right instead of from the inside out.

    To make methods available to values you need to wrap them in a kea object using \bold{x_}. This tags the value as being of class
    'kea', which gives it access to any appropriate (see below) methods. For example,

    \code{letters_ <- x_(letters)}

    attaches the class 'kea' to the character vector a, b, ... ,z and saves the tagged value to the variable 'letters_'. I use
    the convention of always adding an underscore suffix to kea variables, but this convention is not mandatory.

    Any value can be supplied to \bold{x_}.

    \bold{1. Calling Methods}

     The methods available to a kea object depend on the the class and properties of the value given to \bold{x_}. Kea objects containing
    arbitrary values can use methods which have parametres named 'val', 'val1', or 'val2'. For example, \bold{xIdentity} and \bold{xIsTrue} both
    have parametres named 'val', and as such they can be used on functions,
    lists, vectors and any other value you might want to use.

    \bold{x_(sqrt) $ xIdentity()}
    \bold{x_(1:10) $ xIsTrue()}

    Most methods are more selective than this. For example, you can't treat a function as a file path, so the method isn't even available
    to functions.

    \code{x_(sqrt) $ xRead()}

    Which parametre is the kea object given to? That depends on the particular method being called; if there is only one parametre that
    a value fits is used as that parametre. For example, these following two calls are unambigious and identical.

    \code{x_(sqrt) $ xMap(1:10)}
    \code{x_(1:10) $ xMap(sqrt)}

    Here the function 'sqrt' is matched with the parametre 'fn', and the collection 1:10 is matched with the parametre 'coll'.

    For some functions it makes sense to use the left-hand-side kea object as multiple parametres. For example, \bold{xIsIn} an arbitrary value and
    a collection as arguments, so both the following examples make sense.

    \code{x_(1:3) $ xIsIn(1L)}
    \code{x_(1L) $ xIsIn(coll = 1:3)}

    In this case you need to explicitely name \bold{1:3} as 'coll', or it is bound to the parametre 'val' instead.

    \bold{2. Spell-Checking}

    If you mistype a method name kea will attempt to suggest a similar method name, if one exists.
}
\section{Corner Cases}{

   The methods that can be used by \bold{$ x_( )} object varies depending
   on the type of val.
}
\examples{

# 1. Construct an kea object.

x_(letters)

class(x_(letters))

# "kea"

# 2. Get data back out of an kea object.
#
# all methods are available in the form
# 'xMethod' and 'x_Method'. The former returns a kea object
# containing your value, and the latter removes the kea object
# wrapper and just gives you the value.
#
# Calling identity as an unchaining method - x_I _ takes the
# kea object containing the letters, and just returns the letters.

x_(letters) $ x_I()

# 3. Call methods off an kea object.
#
# After creating a kea object you can call methods on it using
# the dollar operator.

csv_string <- "swiss, swiss, german, irish, french, german"

# I try to add underscores to variables that are kea objects.

parsed_ <- x_(csv_string) $ xExplode(", ")
freqs  <- parsed_ $ x_Tabulate()

# list(list("swiss", 2), list("german", 2), list("irish", 1), list("french", 1))

# 4. Chaining methods.
#
# There isn't an advantage to using methods when you only need to apply
# one or two functions to a datum. But you should use methods when you
# need to apply lots of functions to a single datum.
#
# really nested function calls are hard to read, but long chains of
# functions are easy to read.

# good

x_(letters) $ xMap(toupper) $ xRepeat(10) $ xShuffle() $ xTake(30) $ x_Tabulate()

# very bad

xTabulate(
	xTake(30,
		xShuffle(
			xRepeat(10,
				xMap(toupper, letters)
			)
		)
	)
)
}
\seealso{
Other methods: \code{\link{xByCols}};
  \code{\link{xByLevels}}; \code{\link{xByRows}};
  \code{\link{xByValues}}; \code{\link{xElemsByCols}};
  \code{\link{xElemsByRows}}; \code{\link{xExecute}}
}

