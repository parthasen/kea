% Generated by roxygen2 (4.0.1.99): do not edit by hand
\name{x_}
\alias{x_}
\alias{x__}
\title{x_}
\usage{
x_(val)

x__(...)
}
\arguments{
\item{val}{an arbitrary value. The value to wrap in an
   kea object.
   The methods available depend on the input
   type; functions and collections have the most methods available.}

\item{...}{see above.}
}
\value{
An object of class "kea". Internally the object is represented as a
   list with a single field \bold{x}, but this field cannot be accessed directly.
   Instead, the method \bold{$ x_( )} or \bold{$ x_Identity( )} can be used to
   return the data stored in an kea object.

   The methods available to an kea object depend on the type of the data it
   contains. All kea objects inherit a handful of methods regardless of their
   type; these include \bold{xIdentity} and \bold{xTap} - a method that allows
   anonymous function to be executed on an kea object.

   The two primary groups of methods are collection methods and function methods.
}
\description{
Generate an kea object with methods available to it.
}
\section{Corner Cases}{

   The methods that can be used by \bold{$ x_( )} object varies depending
   on the type of val.
}
\examples{

# 1. Construct an kea object.

x_(letters)

class(x_(letters))

# "kea"

# 2. Get data back out of an kea object.
#
# all methods are available in the form
# 'xMethod' and 'x_Method'. The former returns a kea object
# containing your value, and the latter removes the kea object
# wrapper and just gives you the value.
#
# Calling identity as an unchaining method - x_I _ takes the
# kea object containing the letters, and just returns the letters.

x_(letters) $ x_I()

# 3. Call methods off an kea object.
#
# After creating a kea object you can call methods on it using
# the dollar operator.

csv_string <- "swiss, swiss, german, irish, french, german"

# I try to add underscores to variables that are kea objects.

parsed_ <- x_(csv_string) $ xExplode(", ")
freqs  <- parsed_ $ x_Tabulate()

# list(list("swiss", 2), list("german", 2), list("irish", 1), list("french", 1))

# 4. Chaining methods.
#
# There isn't an advantage to using methods when you only need to apply
# one or two functions to a datum. But you should use methods when you
# need to apply lots of functions to a single datum.
#
# really nested function calls are hard to read, but long chains of
# functions are easy to read.

# good

x_(letters) $ xMap(toupper) $ xRepeat(10) $ xShuffle() $ xTake(30) $ x_Tabulate()

# very bad

xTabulate(
	xTake(30,
		xShuffle(
			xRepeat(10,
				xMap(toupper, letters)
			)
		)
	)
)
}
\seealso{
Other methods: \code{\link{xByColkeys}};
  \code{\link{xByCols}}; \code{\link{xByLevels}};
  \code{\link{xByRowkeys}}; \code{\link{xByRows}};
  \code{\link{xByValues}}; \code{\link{xElemsByCols}};
  \code{\link{xElemsByRows}}; \code{\link{xExecute}};
  \code{\link{xTap}}
}

