% Generated by roxygen2 (4.0.1.99): do not edit by hand
\name{xScan}
\alias{xScan}
\alias{xScan_}
\title{xScan}
\usage{
xScan(fn, val, coll)

xScan_(fn, val, ...)
}
\arguments{
\item{fn}{a binary function that returns a value that
   \bold{fn} can later take as its right argument.}

\item{val}{an arbitrary value. The initial value to be
   used as the first left argument to \bold{fn}.}

\item{coll}{a collection. The collection to successively
   reduce to a single value.}

\item{...}{see above.}
}
\value{
A list with its initial element being \bold{coll}, and
	  containing \bold{length(coll) + 1}.
}
\description{
Successively combine a list of values into a single value
using a binary function (left to right, with an initial value).
Return a list containing each intermediate result, and the final result.
}
\details{
Fold successively combines the first two elements of a collection
into one element, until only one element is remaining. The
combining is done with with a binary combining function. Examples
of such functions - functions that take two elements and combine
them into one element - include the plus operator and list
concatenation.

\bold{Associative vs Non-Associative Values.}

There are two important types of combining functions: associative and
non-associative. The difference between these functions is best
demonstrated using infix notation. An example of an associative function
is the plus operator, because the following equation holds

\code{(a + b) + c == a + (b + c)}

for arbitrary numbers a, b, c. Bracketing from the left or the right
does not alter the result of adding several numbers together.
The below example involves using \bold{xFold} to add a vector of numbers.
\bold{xFold} successively combines (with +) the leftmost two values into
a single number, and repeats the process until the sum of the entire list
is found.

\code{xFold('+', 0, 1:5)}

\code{(((((0 + 1) + 2) + 3) + 4) + 5)}

\code{0 + 1 + 2 + 3 + 4 + 5}
\code{1 + 2 + 3 + 4 + 5}

\code{3 + 3 + 4 + 5}

\code{6 + 4 + 5}

\code{10 + 5}

\code{15}

As stated above the plus operator is associative, so both
\bold{xFold} or \bold{xFold} yield the same result.

Non-associative combining functions often focus on accumulating
a data structure entirely different from the input collection,
one element at a time. In the following example
a non-associative combining function takes an tally list
that counts votes for bsd versus linux as its left argument, and a
vote as its right argument. If the vote is for bsd or linux the tally list
is updated, if not it is returned as is.

\code{combiner <- (acc : elem) := if (elem in names(acc)) elem[[acc]] + 1 else acc}

\code{votes <- c('linux', 'mac', 'mac', 'bsd', 'windows', 'linux')}

\code{xFold(combiner, list(linux = 0, bsd = 0), votes) }

The votes are tallied in the following order:

\code{list(linux = 0, bsd = 0), 'linux', 'mac', 'mac', 'bsd', 'windows', 'linux'}

\code{list(linux = 1, bsd = 0), 'mac', 'mac', 'bsd', 'windows', 'linux'}

\code{list(linux = 1, bsd = 0), 'mac', 'bsd', 'windows', 'linux'}

\code{list(linux = 1, bsd = 0), 'bsd', 'windows', 'linux'}

\code{list(linux = 1, bsd = 1), 'windows', 'linux'}

\code{list(linux = 2, bsd = 1), 'linux'}

\code{list(linux = 3, bsd = 1)}

The combining function is non-associative, since it increments a field in its
left argument, while the right argument doesn't even have fields.

\bold{Short-Circuiting}

The folds examined so far involve iterating over an entire input collection.
When the input collections are very long this isn't always desirable.
Sometimes it is possible - an more efficent - to return a result
before checking every element of the input collection.

A good demonstration of short circuiting is to improve the efficiency of
searching for a value. For example, if we want to check if a collection
contains any na value we could (but shouldn't) use the following inefficient code.

\code{coll <- c(1, 2, 3, NA, rep(10, 1000))}

\code{xFold((acc : elem) := acc || is.na(elem), False, coll)}

\code{True}
x
The obvious problem is the fourth element of the very long collection is na,
but the code searches though thousands of elements after finding a match. If
we were searching the collection with a for loop we would use \bold{break} or \bold{return( )}
to terminate the search early and return true. Kiwi adds a similar construct for
terminating certain higher-order functions called the \bold{Return( )} function.

This function can be used to break out of the fold early; in this case upon
discovery of an na value.

\code{xFold((acc : elem) := if (is.na(elem)) Return(True) else False, False, coll)}

The use of \bold{Return( )} reduces the number of steps required to return a result
from thousands to less than ten.
}
\section{Type Signature}{

    (any -> any -> any) -> any -> [any]
}

\section{Corner Cases}{

	  Returns \bold{list(val)} if \bold{coll} is length-zero.
}
\examples{

# 1. How many lines are there in "The Twelve Days of Christmas"?
#    [lyrics from Wikipedia]
#
#    it is a cumulative song, with each new verse adding an extra line
#
#    V1. (1 line)
#    On the First day of Christmas my true love sent to me
#    a Partridge in a Pear Tree.
#
#    V2. (2 lines)
#    On the Second day of Christmas my true love sent to me
#    Two Turtle Doves
#    and a Partridge in a Pear Tree.
#
#    V3. (3 lines)
#    On the Third day of Christmas my true love sent to me
#    Three French Hens,
#    Two Turtle Doves
#    and a Partridge in a Pear Tree.
#
#    The song continues for twelve verses.
#
#    How many lines are sung in total?
#
#   scan lets you see the cumulative number of lines sung by the end of each verse.
#
#   total lines = 1 + 2 + 3 + ... + 12
#
#   scan generates the sequence 0, 1, (1 + 2), (1 + 2 + 3), ...., (1 + 2 + ... + 12)

xScan("+", 0, 1:12)

# list(0, 1, 3, 6, 10, 15, 21, 28, 36, 45, 55, 66, 78)
}
\seealso{
Other folding_functions: \code{\link{xFold}},
  \code{\link{xFold_}}; \code{\link{xReduce}},
  \code{\link{xReduce_}}

Other short_circuiting_functions: \code{\link{xFold}},
  \code{\link{xFold_}}; \code{\link{xIterate}};
  \code{\link{xReduce}}, \code{\link{xReduce_}}
}

