% Generated by roxygen2 (4.0.1.99): do not edit by hand
\name{xMap}
\alias{xMap}
\alias{xMap_}
\title{xMap}
\usage{
xMap(fn, coll)

xMap_(fn, ...)
}
\arguments{
\item{fn}{a unary function. The function to modify each
   element of a collection with.}

\item{coll}{a collection. The collection to be modified.}

\item{...}{see above.}
}
\value{
A list.
}
\description{
Apply a function to each element of a collection.
}
\details{
\bold{xMap} is probably the most commonly used higher-order function.
    It is also one of the easier ones to understand. \bold{xMap} takes a function
    that works on a single value (like \bold{isTRUE}) and a collection of such values.
    It then calls that function on each element of a collection.

    \code{xMap(isTRUE, list(True, False, 10))}

    is essentially transformed to

    \code{list(isTRUE(True), isTRUE(False), isTRUE(10))}

    which result in

    \code{list(True, False, False)}
}
\section{Type Signature}{

    (any -> any) -> |any| -> [any]
}

\section{Corner Cases}{

   Returns the empty list if \bold{coll} is length-zero.
}
\examples{

# 1. Convert letters to uppercase.

LETTERS <- xMap(toupper, letters)
LETTERS

# list(
#    "A", "B", "C", "D", "E", "F",
#    "G", "H", "I", "J", "K", "L",
#    "M", "N", "O", "P", "Q", "R",
#    "S", "T", "U", "V", "W", "X",
#    "Y", "Z")

# 2. grab the second value in a collection
#    of collections.

xMap_(
    xSecondOf,
    list("a", "b", "c"),
    list(1, 2, 3)
)

# list("b", 2)



# 3. HackerRank Functional Programming
# Evaluate the first 10 terms of the series of e^x

# The number e^x is given by the series

# 1 + x + x^2/2! + x^3/3! + ...,

# This problem is perfect for xMap and xReduce.
# The moderately astute will notice that

# x = x^1 / 1!, and that 1 = x^0 / 0!,

# meaning that the first two terms aren't any more difficult
# to generate than the rest of the series. The series really is

# x^0/0! + x^1/1! + x^2/2! + x^3/3! + ...,

# which means we can map over the sequence 0, 1, ... and generate
# the corresponding term in the series e^x

power_of_e <- x := {

	x_(0:15)$
	xMap(ith := {
		(x^ith) / factorial(ith)
	})$
	x_Reduce('+')

}

power_of_e(1)
# 2.718282

# 4. Partially apply map to create a vectorised function
#
# (in this case, '-' is already vectorised)

negate <- xMap(`-`)
negate(1:3)

# c(-1L, -2L, -3L)
}
\seealso{
Other function_application_functions: \code{\link{xApply}},
  \code{\link{xApply_}}; \code{\link{xDeepMap}},
  \code{\link{xDeepMap_}}; \code{\link{xFlatMap}},
  \code{\link{xFlatMap_}}; \code{\link{xInvoke}},
  \code{\link{xInvoke_}}; \code{\link{xRelate}},
  \code{\link{xRelate_}}; \code{\link{xThread}},
  \code{\link{xThread_}}
}

