% Generated by roxygen2 (4.0.1.99): do not edit by hand
\docType{data}
\name{xList}
\alias{xList}
\title{xList[ ]}
\format{\preformatted{function (...)  
 - attr(*, "srcref")=Class 'srcref'  atomic [1:8] 75 2 84 2 9 9 75 84
  .. ..- attr(*, "srcfile")=Classes 'srcfilecopy', 'srcfile' <environment: 0x2b292c8> 
 - attr(*, "class")= chr "xlist_builder"
}}
\usage{
xList
}
\description{
Generate a list using set-builder notation.
}
\details{
\bold{xList} allows for shorthand construction of lists using a form of set-builder notation.
   The notation typically looks like

   \code{S = {2.x | x e 1..100, x^2 > 3}}

   which reads "S is the set of numbers '2x' from the
   numbers 1...100, where x^2 is larger than three".
   In general the syntax is of the form

   \code{S = {output expression, variable e set, predicate expression}}

   Kea's syntax is similar

   \code{S <- xList[ 2*x, x <- 1:10 x^2 > 3 ]}

   \code{S <- xList[output expression, variable <- set, predicate expression]}

   Collection comprehensions are a shorthand for several operations; taking
   the \bold{set product} of several collections, \bold{selecting} them based
   on a predicate, and \bold{mapping} a function over each result.

   \bold{1 The output expression}

   The output expression corresponds to the map operation mentioned above.
   The for comprehension

   \code{xList[2*x, x <- 1:10]}

   is loosely translated into normal kea code as

   \code{xMap(x := x^2, 1:10)}

   \bold{2 Variable bindings}

   At least one variable must be bound for a non-empty list
   comprehension. Multiple variables may also be bound.

   \code{xList[list(x, y), x <- 1:3, y <- 1:3]}

   The above comprehension loosely translates as

   \code{x_(xSetProd(1:3, 1:3)) $ xMap( xUnspread((x : y) := c(x, y)) )}

   \bold{3 The predicate expression (optional)}

   If the final expression given to a comprehension is not a binding
   expression it is treated as a predicate for selecting particular
   values. this is optional. If it isn't included no elements are filtered out.

   \code{xList[c(a, b), a <- 1:3, b <- 1:3, a + b > 2]}

   In the above pairs of a, b such that their sum is larger than
   two are returned.
}
\section{Corner Cases}{

    Returns the empty list when no arguments are given.
}
\examples{

# 1. select prime numbers

primes <- upper := {

	is_prime <- num := {
	    if (num == 2) True else min(num \%\% 2:(num - 1)) > 0
	}

	xList[num, num <- 1:upper, is_prime(num)]
}

primes(17)

# list(2, 3, 5, 7, 11, 13, 17, 19)

# 2. xList has normal lexical scoping

first_name <- "Jack"
xList[paste(first_name, mid, sir), mid <- c('K', 'M'), sir <- c("Black", "Brown", "Gray")]

# list("Jack K Black", "Jack M Black",
#      "Jack K Brown", "Jack M Brown",
#      "Jack K Gray", "Jack M Gray")


# 3.
# Using list comprehensions to process tabular data.

raw_health_ranking <-
"
1     France             4
2     Italy             11
3     San-Marino        21
4     Andorra           23
5     Malta             37
6     Singapore         38
7     Spain             24
8     Oman              62
9     Austria            6
10    Japan             13
11    Norway            16
12    Portugal          27
13    Monaco            12
14    Greece            30
15    Iceland           14
16    Luxembourg         5
17    Netherlands        9
18    United-Kingdom    26
"

health_ranking <-
	x_(raw_health_ranking) $ xToLines() $ x_Map(xToWords)

top_twenty_countries <-
	xList[ tolower( row[[2]] ), row <- health_ranking ]

# list(
#	"france", "italy", "san-marino", "andorra",
#	"malta", "singapore", "spain", "oman", "austria",
#	"japan", "norway", "portugal", "monaco",
#	"greece", "iceland", "luxembourg", "netherlands",
#	"united-kingdom"
# )
}
\keyword{datasets}

