% Generated by roxygen2 (4.0.1.99): do not edit by hand
\name{relist}
\alias{:=}
\alias{relist}
\title{xLambda}
\usage{
relist(expr)

":="(sym, val)
}
\arguments{
\item{sym}{a parametre expression. The parametres to bind to
   to the function.}

\item{val}{an expression. The body of the function.}
}
\value{
Returns a function.
}
\description{
Syntactic sugar for creating functions.
}
\details{
As of version 0.1.0 xLambda functions cannot have default parametres. This
    may change at a later date.

    The parametre expression is of the form

    \code{x}

    Or

    \code{(x)}

    Or

    \code{(x : y : z)}

   Due to parser limitations parametres are colon-delimited, not comma delimited. Non-unary
   functions must enclose their parametres in parentheses.

   The body of the function can optionally be enclosed in braces. The ':=' operator has very low
   preceedence, so sometimes parametres may be necessary for the correct function to be created.

   \code{x := x^2 \%then\% x := x}

   is interpreted as

   \code{x := {x^2 \%then\% x := x}}

   . In this case

   \code{(x := x^2) \%then\% (x := x)}

   is required to create the correct composed function.
}
\examples{

# 1. greatest common divisor:
#    a multi parametre function.

gcd <- (a : b) := {
    if (b == 0) a else gcd(b, a \%\% b)
}

gcd(156, 87)

# 2. Boolean logic using only functions.

true  <- x := y := x # \\x.\\y.x
false <- x := y := y # \\x.\\y.y

# if the function is 'true', the first value True is returned.
# if the function is 'false', the second value False is returned.

to_bool <- f := f(True, False)

# now for the operators and if statement.

and <- p := q := p(q)(p)
or  <- p := q := p(p)(q)

not <- p := a := b := p(b)(a)

# if the function p is 'true', then the first
# value a is returned. Otherwise the second value is returned.
case <- p := a := b := p(a)(b)

case( and(true)(false) )('case was true')('case was false')

# 'case was false'
}

