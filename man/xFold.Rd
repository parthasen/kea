% Generated by roxygen2 (4.0.1.99): do not edit by hand
\name{xFold}
\alias{xFold}
\alias{xFold_}
\title{xFold}
\usage{
xFold(fn, val, coll)

xFold_(fn, val, ...)
}
\arguments{
\item{fn}{a binary function that returns a value that
   \bold{fn} can later take as its left argument.}

\item{val}{an arbitrary value. The initial value to be
   used as the first left argument to \bold{fn}.}

\item{coll}{a collection. The collection to reduce to a
   single value.}

\item{...}{see above.}
}
\value{
An arbitrary value, depending on the function \bold{fn}.
}
\description{
Successively combine a collection of values into a single value
using a binary function (left to right, with an initial value).
}
\details{
Fold successively combines the first two elements of a collection
into one element, until only one element is remaining. The
combining is done with with a binary combining function. Examples
of such functions - functions that take two elements and combine
them into one element - include the plus operator and list
concatenation.

\bold{Associative vs Non-Associative Values.}

There are two important types of combining functions: associative and
non-associative. The difference between these functions is best
demonstrated using infix notation. An example of an associative function
is the plus operator, because the following equation holds

\code{(a + b) + c == a + (b + c)}

for arbitrary numbers a, b, c. Bracketing from the left or the right
does not alter the result of adding several numbers together.
The below example involves using \bold{xFold} to add a vector of numbers.
\bold{xFold} successively combines (with +) the leftmost two values into
a single number, and repeats the process until the sum of the entire list
is found.

\code{xFold('+', 0, 1:5)}

\code{(((((0 + 1) + 2) + 3) + 4) + 5)}

\code{0 + 1 + 2 + 3 + 4 + 5}
\code{1 + 2 + 3 + 4 + 5}

\code{3 + 3 + 4 + 5}

\code{6 + 4 + 5}

\code{10 + 5}

\code{15}

As stated above the plus operator is associative, so both
\bold{xFold} or \bold{xFold} yield the same result.

Non-associative combining functions often focus on accumulating
a data structure entirely different from the input collection,
one element at a time. In the following example
a non-associative combining function takes an tally list
that counts votes for bsd versus linux as its left argument, and a
vote as its right argument. If the vote is for bsd or linux the tally list
is updated, if not it is returned as is.

\code{combiner <- (acc : elem) := if (elem in names(acc)) elem[[acc]] + 1 else acc}

\code{votes <- c('linux', 'mac', 'mac', 'bsd', 'windows', 'linux')}

\code{xFold(combiner, list(linux = 0, bsd = 0), votes) }

The votes are tallied in the following order:

\code{list(linux = 0, bsd = 0), 'linux', 'mac', 'mac', 'bsd', 'windows', 'linux'}

\code{list(linux = 1, bsd = 0), 'mac', 'mac', 'bsd', 'windows', 'linux'}

\code{list(linux = 1, bsd = 0), 'mac', 'bsd', 'windows', 'linux'}

\code{list(linux = 1, bsd = 0), 'bsd', 'windows', 'linux'}

\code{list(linux = 1, bsd = 1), 'windows', 'linux'}

\code{list(linux = 2, bsd = 1), 'linux'}

\code{list(linux = 3, bsd = 1)}

The combining function is non-associative, since it increments a field in its
left argument, while the right argument doesn't even have fields.

\bold{Short-Circuiting}

The folds examined so far involve iterating over an entire input collection.
When the input collections are very long this isn't always desirable.
Sometimes it is possible - an more efficent - to return a result
before checking every element of the input collection.

A good demonstration of short circuiting is to improve the efficiency of
searching for a value. For example, if we want to check if a collection
contains any na value we could (but shouldn't) use the following inefficient code.

\code{coll <- c(1, 2, 3, NA, rep(10, 1000))}

\code{xFold((acc : elem) := acc || is.na(elem), False, coll)}

\code{True}
x
The obvious problem is the fourth element of the very long collection is na,
but the code searches though thousands of elements after finding a match. If
we were searching the collection with a for loop we would use \bold{break} or \bold{return( )}
to terminate the search early and return true. Kea adds a similar construct for
terminating certain higher-order functions called the \bold{Return( )} function.

This function can be used to break out of the fold early; in this case upon
discovery of an na value.

\code{xFold((acc : elem) := if (is.na(elem)) Return(True) else False, False, coll)}

The use of \bold{Return( )} reduces the number of steps required to return a result
from thousands to less than ten.
}
\section{Type Signature}{

    (any -> any -> any) -> any -> |any| -> any
}

\section{Corner Cases}{

   If \bold{coll} is length-zero then the parametre \bold{val}
   is returned automatically.
}
\examples{

# 1. sum a vector with fold.

xFold("+", 0, 1:10)

## 55

# 2. demonstrate how Return works by using
#    it to break out of the fold across 26 letters
#    prematurely.

xFold(
    (number_checked : letter) := {

        if (letter == 'q') {
            Return (number_checked)
        } else {
            number_checked + 1
        }
    },
    0,
    letters
)

# terminated after 16 checks, not 26.
# 16

# 3. HackerRank Functional Programming #4
#    Return the sum of the odd elements of a list

# There are two parts to this problem; selecting the odd numbers from a list
# and then summing them. xSelect is (naturally) the solution to the latter half.
# xFold takes a binary function (in this case 'plus'), and successively merges values (from
# left to right) in a collection until a single result is returned.

# Kea chaining methods work nicely for multi-part processing of data.

sum_odds <- nums := {

    x_(nums) $
    xSelect(
        x := {x \%\% 2 == 1}
    )$
    x_Fold('+', 0)
}

sum_odds(c(1, 2, 3, 4, 5, 6))

# 9

# A more efficient solution would only use xFold; the right argument is checked to see
# if it is odd; if it is it's added to the accumulator value.

sum_odds <- nums := {

    xFold(
        (acc : nextelem) := {
            if (nextelem \%\% 2 == 1) {
                acc + nextelem
            } else {
                acc
            }
        },
        0,
        nums
    )
}

sum_odds(c(1, 2, 3, 4, 5, 6))

9

# 4. HackerRank Functional Programming
#    Remove the odd indices from a collection

# As is normal for functional programming, fold is the solution to all problems.
# Most functions in Kea could actually be expressed by partially applying fold,
# but that would be inefficient.

#
# In this case we want to take a collection xs and keep xs[ 2, 4, 6, ... ]
# We can use xFold to take each index of the collection and only accumulate
# the values at even indices.

remove_odds <- coll := {

    xFold(
        (acc : index) := {
            if (index \%\% 2 == 0) {
                c(acc, coll[index])
            } else {
                acc
            }
        },
        xUnit(coll),
        seq_along(coll)
    )

}

remove_odds(letters)

# c("b", "d", "f", "h", "j", "l", "n", "p", "r", "t", "v", "x", "z")

# 5. HackerRank Functional Programming
# Area under curves and solids of rotation

# Time to flex my atrophied Calculus muscles_

# This particular problem involves finding the area underneath a
# subsection of a polynomial of x, and finding the area of the solid of
# rotation about the x-axis. Luckily numerical integration isn't so hard.

# The easiest way to approximate the area under a curve is to approximate the
# curve with small rectangles, and to summate their area. This isn't a great
# approximation -
# it converges on the true value slowly with respect to rectangle width -
# but it will do here.

# I think this is most naturally expressed with xFold; starting from an initial
# area of 0 add the area of each rectangle under the polynomial to the accumulated area.

integrate <- (f : x_bounds) := {

    epsilon  <- 0.001
    x_values <- seq(from = x_bounds[1], to = x_bounds[2], by = epsilon)

    xFold(
        (area : x) := {
            area + (f(x) * epsilon)
        },
        0,
        x_values
    )
}

integrate(
    x := x^3 - 9*x^2,
    c(-10, +10)
)

# -6000.9

# Wolfram Alpha (where most of my calculus knowledge comes from)
# says -6000, so not bad.
}
\seealso{
Other folding_functions: \code{\link{xReduce}},
  \code{\link{xReduce_}}; \code{\link{xScan}},
  \code{\link{xScan_}}

Other short_circuiting_functions: \code{\link{xIterate}};
  \code{\link{xReduce}}, \code{\link{xReduce_}};
  \code{\link{xScan}}, \code{\link{xScan_}}
}

