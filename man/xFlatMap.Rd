% Generated by roxygen2 (4.0.1.99): do not edit by hand
\name{xFlatMap}
\alias{xFlatMap}
\alias{xFlatMap_}
\title{xFlatMap}
\usage{
xFlatMap(fn, coll)

xFlatMap_(fn, ...)
}
\arguments{
\item{fn}{a unary function. The function to map across a collection.}

\item{coll}{a collection. The collection to map across.}

\item{...}{see above.}
}
\value{
A list.
}
\description{
Concatenate the results of applying a function
to each element of a collection.
}
\details{
\bold{xFlatMap} is similar to \bold{xMap} but allows more
    fine-grained control of the output format. For example, elements
    can be removed (by returning NULL) or added (by returning a collection),
    or names can be added to the collection.

    \bold{xFlatMap} can be used to emulate the behaviour of \bold{xSelect},
    allowing it to drop elements:

    \code{odds <- xFlatMap(x := if (x \%\% 2) x, 1:10)}

    \code{list(1, 3, 5, 7, 9)}

    It may also be used to add new elements to a collection:

    \code{xFlatMap(x := c(num = x, sqrt = sqrt(x)), 1:3)  )}

    \code{list(num = 1, sqrt = 1, num = 2, sqrt = 1.41, num = 3, sqrt = 1.73)}
}
\section{Type Signature}{

    (any -> any) -> |any| -> [any]
}

\section{Corner Cases}{

	  Returns the empty list if \bold{coll} is length-zero.
}
\examples{

# 1. HackerRank Functional Programming
#    Given an input list repeat each element n times

# In this problem each element of a list must be repeated n times;
# so the list

# list(1, 2, 3)

# with n = 2 would be become

# list(1, 1, 2, 2, 3, 3)

# I think xFlatMap is the most elegant way of expressing this
# problem, but (as is usually true) xFold can also be used here.
# xFlatMap is like xMap, but it joins its return values end-to-end;
# for this reason it can return an output collection longer than its
# input collection.

repeat_elements <- (n : coll) := {
	xFlatMap(xRepeat(n), coll)
}

# Here we mapped a partially-applied version of the xRepeat function
# (so it repeats its element n times) over the elements we want to
# repeat; xFlatMap then joins them end-to-end as we need.

repeat_elements(2, c(1, 2, 3))

# list(1, 1, 2, 2, 3, 3)


# 2. Factorions
#    factorions are numbers whose value is the sum of the
#    factorials of its digits. For example,
#    145 = 1! + 4! + 5!
#    the below example uses a lot of chained function composition,
#    to process and sum each digit of the number to search,
#
#    There are only four factorions in base 10:
#
#    1, 2, 145, 40585
#
#    There are more efficient ways to find the numbers,
#    but a brute force search is fun, if really slow.
#
#    For CRAN's sake, I will only find the first three factorions.

digit_factorial_sum_of <-
	paste \%then\% xToChars \%then\% as.integer \%then\% factorial \%then\% sum

x_(1:5000) $
xFlatMap(num := {

	digit_factorial_sum <- digit_factorial_sum_of(num)

	if (digit_factorial_sum == num) {
		digit_factorial_sum
	}

})
}
\seealso{
Other function_application_functions: \code{\link{xApply}},
  \code{\link{xApply_}}; \code{\link{xDeepMap}},
  \code{\link{xDeepMap_}}; \code{\link{xMap}},
  \code{\link{xMap_}}; \code{\link{xSpread}};
  \code{\link{xThread}}, \code{\link{xThread_}};
  \code{\link{xUnspread}}
}

